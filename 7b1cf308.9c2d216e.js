(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{123:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return b})),n.d(t,"rightToc",(function(){return i})),n.d(t,"default",(function(){return s}));var a=n(2),c=n(6),o=(n(0),n(147)),r={id:"api-reference-selection-state",title:"SelectionState"},b={id:"api-reference-selection-state",title:"SelectionState",description:"SelectionState is an Immutable",source:"@site/../docs/APIReference-SelectionState.md",permalink:"/docs/api-reference-selection-state",editUrl:"https://github.com/facebook/draft-js/edit/master/docs/../docs/APIReference-SelectionState.md",lastUpdatedBy:"Rounak Agarwal",lastUpdatedAt:1595959264,sidebar:"docs",previous:{title:"Entity",permalink:"/docs/api-reference-entity"},next:{title:"CompositeDecorator",permalink:"/docs/api-reference-composite-decorator"}},i=[{value:"Keys and Offsets",id:"keys-and-offsets",children:[]},{value:"Start/End vs. Anchor/Focus",id:"startend-vs-anchorfocus",children:[]},{value:"Overview",id:"overview",children:[]},{value:"Static Methods",id:"static-methods",children:[{value:"<code>createEmpty()</code>",id:"createempty",children:[]}]},{value:"Methods",id:"methods",children:[{value:"<code>getStartKey()</code>",id:"getstartkey",children:[]},{value:"<code>getStartOffset()</code>",id:"getstartoffset",children:[]},{value:"<code>getEndKey()</code>",id:"getendkey",children:[]},{value:"<code>getEndOffset()</code>",id:"getendoffset",children:[]},{value:"<code>getAnchorKey()</code>",id:"getanchorkey",children:[]},{value:"<code>getAnchorOffset()</code>",id:"getanchoroffset",children:[]},{value:"<code>getFocusKey()</code>",id:"getfocuskey",children:[]},{value:"<code>getFocusOffset()</code>",id:"getfocusoffset",children:[]},{value:"<code>getIsBackward()</code>",id:"getisbackward",children:[]},{value:"<code>getHasFocus()</code>",id:"gethasfocus",children:[]},{value:"<code>isCollapsed()</code>",id:"iscollapsed",children:[]},{value:"<code>hasEdgeWithin()</code>",id:"hasedgewithin",children:[]},{value:"<code>serialize()</code>",id:"serialize",children:[]}]},{value:"Properties",id:"properties",children:[{value:"<code>anchorKey</code>",id:"anchorkey",children:[]},{value:"<code>anchorOffset</code>",id:"anchoroffset",children:[]},{value:"<code>focusKey</code>",id:"focuskey",children:[]},{value:"<code>focusOffset</code>",id:"focusoffset",children:[]},{value:"<code>isBackward</code>",id:"isbackward",children:[]},{value:"<code>hasFocus</code>",id:"hasfocus",children:[]}]}],l={rightToc:i};function s(e){var t=e.components,n=Object(c.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"SelectionState")," is an Immutable\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://web.archive.org/web/20150623131347/http://facebook.github.io:80/immutable-js/docs/#/Record"}),"Record"),"\nthat represents a selection range in the editor."),Object(o.b)("p",null,"The most common use for the ",Object(o.b)("inlineCode",{parentName:"p"},"SelectionState")," object is via ",Object(o.b)("inlineCode",{parentName:"p"},"EditorState.getSelection()"),",\nwhich provides the ",Object(o.b)("inlineCode",{parentName:"p"},"SelectionState")," currently being rendered in the editor."),Object(o.b)("h3",{id:"keys-and-offsets"},"Keys and Offsets"),Object(o.b)("p",null,"A selection range has two points: an ",Object(o.b)("strong",{parentName:"p"},"anchor")," and a ",Object(o.b)("strong",{parentName:"p"},"focus"),". (Read more on\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/Selection#Glossary"}),"MDN"),")."),Object(o.b)("p",null,"The native DOM approach represents each point as a Node/offset pair, where the offset\nis a number corresponding either to a position within a Node's ",Object(o.b)("inlineCode",{parentName:"p"},"childNodes")," or, if the\nNode is a text node, a character offset within the text contents."),Object(o.b)("p",null,"Since Draft maintains the contents of the editor using ",Object(o.b)("inlineCode",{parentName:"p"},"ContentBlock")," objects,\nwe can use our own model to represent these points. Thus, selection points are\ntracked as key/offset pairs, where the ",Object(o.b)("inlineCode",{parentName:"p"},"key")," value is the key of the ",Object(o.b)("inlineCode",{parentName:"p"},"ContentBlock"),"\nwhere the point is positioned and the ",Object(o.b)("inlineCode",{parentName:"p"},"offset")," value is the character offset\nwithin the block."),Object(o.b)("h3",{id:"startend-vs-anchorfocus"},"Start/End vs. Anchor/Focus"),Object(o.b)("p",null,"The concept of ",Object(o.b)("strong",{parentName:"p"},"anchor")," and ",Object(o.b)("strong",{parentName:"p"},"focus")," is very useful when actually rendering\na selection state in the browser, as it allows us to use forward and backward\nselection as needed. For editing operations, however, the direction of the selection\ndoesn't matter. In this case, it is more appropriate to think in terms of\n",Object(o.b)("strong",{parentName:"p"},"start")," and ",Object(o.b)("strong",{parentName:"p"},"end")," points."),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"SelectionState")," therefore exposes both anchor/focus values and\nstart/end values. When managing selection behavior, we recommend that\nyou work with ",Object(o.b)("em",{parentName:"p"},"anchor")," and ",Object(o.b)("em",{parentName:"p"},"focus")," values to maintain selection direction.\nWhen managing content operations, however, we recommend that you use ",Object(o.b)("em",{parentName:"p"},"start"),"\nand ",Object(o.b)("em",{parentName:"p"},"end")," values."),Object(o.b)("p",null,"For instance, when extracting a slice of text from a block based on a\n",Object(o.b)("inlineCode",{parentName:"p"},"SelectionState"),", it is irrelevant whether the selection is backward:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"var selectionState = editorState.getSelection();\nvar anchorKey = selectionState.getAnchorKey();\nvar currentContent = editorState.getCurrentContent();\nvar currentContentBlock = currentContent.getBlockForKey(anchorKey);\nvar start = selectionState.getStartOffset();\nvar end = selectionState.getEndOffset();\nvar selectedText = currentContentBlock.getText().slice(start, end);\n")),Object(o.b)("p",null,"Note that ",Object(o.b)("inlineCode",{parentName:"p"},"SelectionState")," itself tracks only ",Object(o.b)("em",{parentName:"p"},"anchor")," and ",Object(o.b)("em",{parentName:"p"},"focus")," values.\n",Object(o.b)("em",{parentName:"p"},"Start")," and ",Object(o.b)("em",{parentName:"p"},"end")," values are derived."),Object(o.b)("h2",{id:"overview"},"Overview"),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Static Methods")),Object(o.b)("ul",{class:"apiIndex"},Object(o.b)("li",null,Object(o.b)("a",{href:"#createempty"},Object(o.b)("pre",null,"static createEmpty(blockKey)")))),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Methods")),Object(o.b)("ul",{class:"apiIndex"},Object(o.b)("li",null,Object(o.b)("a",{href:"#getstartkey"},Object(o.b)("pre",null,"getStartKey()"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#getstartoffset"},Object(o.b)("pre",null,"getStartOffset()"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#getendkey"},Object(o.b)("pre",null,"getEndKey()"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#getendoffset"},Object(o.b)("pre",null,"getEndOffset()"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#getanchorkey"},Object(o.b)("pre",null,"getAnchorKey()"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#getanchoroffset"},Object(o.b)("pre",null,"getAnchorOffset()"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#getfocuskey"},Object(o.b)("pre",null,"getFocusKey()"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#getfocusoffset"},Object(o.b)("pre",null,"getFocusOffset()"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#getisbackward"},Object(o.b)("pre",null,"getIsBackward()"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#gethasfocus"},Object(o.b)("pre",null,"getHasFocus()"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#iscollapsed"},Object(o.b)("pre",null,"isCollapsed()"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#hasedgewithin"},Object(o.b)("pre",null,"hasEdgeWithin(blockKey, start, end)"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#serialize"},Object(o.b)("pre",null,"serialize()")))),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Properties")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Use ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://web.archive.org/web/20150623131347/http://facebook.github.io:80/immutable-js/docs/#/Map"}),"Immutable Map API")," to\nset properties."),Object(o.b)("p",{parentName:"blockquote"},Object(o.b)("strong",{parentName:"p"},"Example")),Object(o.b)("pre",{parentName:"blockquote"},Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const selectionState = SelectionState.createEmpty();\nconst selectionStateWithNewFocusOffset = selection.set('focusOffset', 1);\n"))),Object(o.b)("ul",{class:"apiIndex"},Object(o.b)("li",null,Object(o.b)("a",{href:"#anchorkey"},Object(o.b)("pre",null,"anchorKey"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#anchoroffset"},Object(o.b)("pre",null,"anchorOffset"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#focuskey"},Object(o.b)("pre",null,"focusKey"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#focusoffset"},Object(o.b)("pre",null,"focusOffset"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#isbackward"},Object(o.b)("pre",null,"isBackward"))),Object(o.b)("li",null,Object(o.b)("a",{href:"#hasfocus"},Object(o.b)("pre",null,"hasFocus")))),Object(o.b)("h2",{id:"static-methods"},"Static Methods"),Object(o.b)("h3",{id:"createempty"},Object(o.b)("inlineCode",{parentName:"h3"},"createEmpty()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"createEmpty(blockKey: string): SelectionState\n")),Object(o.b)("p",null,"Create a ",Object(o.b)("inlineCode",{parentName:"p"},"SelectionState")," object at the zero offset of the provided block key\nand ",Object(o.b)("inlineCode",{parentName:"p"},"hasFocus")," set to false."),Object(o.b)("h2",{id:"methods"},"Methods"),Object(o.b)("h3",{id:"getstartkey"},Object(o.b)("inlineCode",{parentName:"h3"},"getStartKey()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"getStartKey(): string\n")),Object(o.b)("p",null,"Returns the key of the block containing the start position of the selection range."),Object(o.b)("h3",{id:"getstartoffset"},Object(o.b)("inlineCode",{parentName:"h3"},"getStartOffset()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"getStartOffset(): number\n")),Object(o.b)("p",null,"Returns the block-level character offset of the start position of the selection range."),Object(o.b)("h3",{id:"getendkey"},Object(o.b)("inlineCode",{parentName:"h3"},"getEndKey()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"getEndKey(): string\n")),Object(o.b)("p",null,"Returns the key of the block containing the end position of the selection range."),Object(o.b)("h3",{id:"getendoffset"},Object(o.b)("inlineCode",{parentName:"h3"},"getEndOffset()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"getEndOffset(): number\n")),Object(o.b)("p",null,"Returns the block-level character offset of the end position of the selection range."),Object(o.b)("h3",{id:"getanchorkey"},Object(o.b)("inlineCode",{parentName:"h3"},"getAnchorKey()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"getAnchorKey(): string\n")),Object(o.b)("p",null,"Returns the key of the block containing the anchor position of the selection range."),Object(o.b)("h3",{id:"getanchoroffset"},Object(o.b)("inlineCode",{parentName:"h3"},"getAnchorOffset()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"getAnchorOffset(): number\n")),Object(o.b)("p",null,"Returns the block-level character offset of the anchor position of the selection range."),Object(o.b)("h3",{id:"getfocuskey"},Object(o.b)("inlineCode",{parentName:"h3"},"getFocusKey()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"getFocusKey(): string\n")),Object(o.b)("p",null,"Returns the key of the block containing the focus position of the selection range."),Object(o.b)("h3",{id:"getfocusoffset"},Object(o.b)("inlineCode",{parentName:"h3"},"getFocusOffset()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"getFocusOffset(): number\n")),Object(o.b)("p",null,"Returns the block-level character offset of the focus position of the selection range."),Object(o.b)("h3",{id:"getisbackward"},Object(o.b)("inlineCode",{parentName:"h3"},"getIsBackward()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"getIsBackward(): boolean\n")),Object(o.b)("p",null,"Returns whether the focus position is before the anchor position in the document."),Object(o.b)("p",null,"This must be derived from the key order of the active ",Object(o.b)("inlineCode",{parentName:"p"},"ContentState"),", or if the selection\nrange is entirely within one block, a comparison of the anchor and focus offset values."),Object(o.b)("h3",{id:"gethasfocus"},Object(o.b)("inlineCode",{parentName:"h3"},"getHasFocus()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"getHasFocus(): boolean\n")),Object(o.b)("p",null,"Returns whether the editor has focus."),Object(o.b)("h3",{id:"iscollapsed"},Object(o.b)("inlineCode",{parentName:"h3"},"isCollapsed()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"isCollapsed(): boolean\n")),Object(o.b)("p",null,"Returns whether the selection range is collapsed, i.e. a caret. This is true\nwhen the anchor and focus keys are the same /and/ the anchor and focus offsets\nare the same."),Object(o.b)("h3",{id:"hasedgewithin"},Object(o.b)("inlineCode",{parentName:"h3"},"hasEdgeWithin()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"hasEdgeWithin(blockKey: string, start: number, end: number): boolean\n")),Object(o.b)("p",null,"Returns whether the selection range has an edge that overlaps with the specified\nstart/end range within a given block."),Object(o.b)("p",null,"This is useful when setting DOM selection within a block after contents are\nrendered."),Object(o.b)("h3",{id:"serialize"},Object(o.b)("inlineCode",{parentName:"h3"},"serialize()")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"serialize(): string\n")),Object(o.b)("p",null,"Returns a serialized version of the ",Object(o.b)("inlineCode",{parentName:"p"},"SelectionState"),". Useful for debugging."),Object(o.b)("h2",{id:"properties"},"Properties"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Use ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://web.archive.org/web/20150623131347/http://facebook.github.io:80/immutable-js/docs/#/Map"}),"Immutable Map API")," to\nset properties.")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"var selectionState = SelectionState.createEmpty('foo');\nvar updatedSelection = selectionState.merge({\n  focusKey: 'bar',\n  focusOffset: 0,\n});\nvar anchorKey = updatedSelection.getAnchorKey(); // 'foo'\nvar focusKey = updatedSelection.getFocusKey(); // 'bar'\n")),Object(o.b)("h3",{id:"anchorkey"},Object(o.b)("inlineCode",{parentName:"h3"},"anchorKey")),Object(o.b)("p",null,"The block containing the anchor end of the selection range."),Object(o.b)("h3",{id:"anchoroffset"},Object(o.b)("inlineCode",{parentName:"h3"},"anchorOffset")),Object(o.b)("p",null,"The offset position of the anchor end of the selection range."),Object(o.b)("h3",{id:"focuskey"},Object(o.b)("inlineCode",{parentName:"h3"},"focusKey")),Object(o.b)("p",null,"The block containing the focus end of the selection range."),Object(o.b)("h3",{id:"focusoffset"},Object(o.b)("inlineCode",{parentName:"h3"},"focusOffset")),Object(o.b)("p",null,"The offset position of the focus end of the selection range."),Object(o.b)("h3",{id:"isbackward"},Object(o.b)("inlineCode",{parentName:"h3"},"isBackward")),Object(o.b)("p",null,"If the anchor position is lower in the document than the focus position, the selection is backward. Note: The ",Object(o.b)("inlineCode",{parentName:"p"},"SelectionState")," is an object with no knowledge of the ",Object(o.b)("inlineCode",{parentName:"p"},"ContentState")," structure. Therefore, when updating ",Object(o.b)("inlineCode",{parentName:"p"},"SelectionState")," values, you are responsible for updating ",Object(o.b)("inlineCode",{parentName:"p"},"isBackward")," as well."),Object(o.b)("h3",{id:"hasfocus"},Object(o.b)("inlineCode",{parentName:"h3"},"hasFocus")),Object(o.b)("p",null,"Whether the editor currently has focus."))}s.isMDXComponent=!0},147:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return u}));var a=n(0),c=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function b(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,c=function(e,t){if(null==e)return{};var n,a,c={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(c[n]=e[n]);return c}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(c[n]=e[n])}return c}var l=c.a.createContext({}),s=function(e){var t=c.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):b(b({},t),e)),n},d=function(e){var t=s(e.components);return c.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return c.a.createElement(c.a.Fragment,{},t)}},h=c.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),d=s(n),h=a,u=d["".concat(r,".").concat(h)]||d[h]||p[h]||o;return n?c.a.createElement(u,b(b({ref:t},l),{},{components:n})):c.a.createElement(u,b({ref:t},l))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var b={};for(var i in t)hasOwnProperty.call(t,i)&&(b[i]=t[i]);b.originalType=e,b.mdxType="string"==typeof e?e:a,r[1]=b;for(var l=2;l<o;l++)r[l]=n[l];return c.a.createElement.apply(null,r)}return c.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);